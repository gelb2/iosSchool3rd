> #####17.01.19 -  #9 (2주차 4번째 수업)

###프로젝트명
- Day4  
  위 프로젝트의 코드를 전부 해석할 수 있다면  
  상속, 다형성(재정의, 중복정의), 은닉화 등을 이해한다고 할 수 있을 듯


###주제  
- 클래스 끼리의 공통점을 묶어 봅니다. (클래스 상속)  
- 상속받은 행위를 변경해 봅니다. (재정의 : 오버라이딩)  
- 숨겨야 할 정보를 숨겨봅니다. (은닉화)  

#내용

###상속  
- 새로운 클래스가 기존의 클래스의 자료와 연산을 이용할 수 있게 하는 기능  
- NSObject : Objective-C에서의 최상위 루트 클래스

  
###재정의(Override)  
- 부모 클래스에게서 물려받은 성질을 그대로 사용하지 않고   
  자식 클래스에게 맞는 형태 또는 행위로 변경하여 사용할 수 있는 기능      
- 재정의(Override)와 중복정의(Overload)는 OOP의 **다형성**의 또 다른 모습
- Objective-C는 중복정의를 지원하지 않는다.  
  (단, 매개변수 없는 것, 하나 있는 것 두 개를 함께 정의하여 사용할 시, 정상 작동되어 오버로드 된 것처럼 보이나, 오버로드가 아니다.)
- self는 자신, super는 부모 클래스의 메소드를 쓸 수 있다.


###은닉화(Hidden)  
- 다른 객체가 직접 접근할 수 없도록 프로퍼티를 노출하지 않는 방법  
- **카테고리**라는 기능으로 헤더의 프로퍼티를 구현파일로 옮겨올 수 있다. (카테고리는 나중에 배움)


###프로퍼티  
> 어쩌다 보니 알게 된 것들...;; 꿀잼ㅋㅋ  

- 프로퍼티와 변수는 다르다. 
- 헤더에 readonly를 단 프로퍼티 선언하고,  
  소스에 다시 readonly를 뺀 프로퍼티를 써서  
  쓰기 은닉화만 할 수도 있다.  
- 프로퍼티 생성시 getter, setter가 자동 생성된다.  
    > 자동으로 camelCase 적용한 메소드를 만든다.  
   
   - setter  
     ``set프로퍼티명``
   - getter  
     ``get프로퍼티명``  

- 객체 내부 setter 메소드 호출  
     ``self.프로퍼티명 ``  
- **예1 (무한 setter)**  
	1. Grade라는 프로퍼티를 생성함  
	   (setGrade, getGrade 메소드 자동생성)  
	2. setGrade라고 메소드를 만들고  
	   메소드 내에 self.grade를 집어 넣음  
      (생성시 생긴 setter메소드 오버라이딩하게 된 것)  
	3. setGrade 호출하면 내부 self.grade로 다시 setter메소드 호출함  
   4. 재정의(오버라이딩) 된 setter 메소드(setGrade)로 다시 재귀... 무한 setter재귀 빠지게 됨;;;  

- **예2 (readonly 선언 후 setter 메소드 정의)**  
   1. 헤더파일에 readonly로 grade 프로퍼티 생성 후  
   2. setGrade 메소드 생성..  
   3. 결국 read, write 다 됨 (은닉화 안됨;;)  

